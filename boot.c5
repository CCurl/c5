(ha) @ (la) @ (vha) @
: here  (ha)  @ ;
: vhere (vha) @ ;
: last  (la)  @ ;
: c, here dup 1+     (ha) ! c! ;
: w, here dup 2 +    (ha) ! w! ;
: ,  here dup cell + (ha) ! ! ;
: allot vhere + (vha) ! ;
: const addword (lit4) c, , (exit) c, ;
: var   vhere const allot ;

const -vha-
const -la-
const -ha-

: immediate 1 last cell + c! ;
: inline    2 last cell + c! ;

: begin here ; immediate
: while  (jmpnz)  c, , ; immediate
: -while (njmpnz) c, , ; immediate
: until  (jmpz)   c, , ; immediate
: -until (njmpz)  c, , ; immediate
: again  (jmp)    c, , ; immediate

: if (jmpz)   c, here 0 , ; immediate
: -if (njmpz) c, here 0 , ; immediate
: if0 (jmpnz) c, here 0 , ; immediate
: then here swap ! ; immediate

: a+  a@ 1+ a! ; inline
: @a  a@  c@ ; inline
: @a+ a@+ c@ ; inline
: @a- a@- c@ ; inline
: !a+ a@+ c! ; inline
: !t+ t@+ c! ; inline
: !t- t@- c! ; inline
: adrop  a> drop ; inline
: tdrop  t> drop ; inline
: atdrop a> drop t> drop ; inline

: ( >in @ >a 
   begin
      @a+ ')' = if  a@ >in !  adrop  exit  then 
   again ; immediate

( now we can have comments! )

: comp?   ( --n ) state @ ;
: (quote) ( -- )  vhere dup >t  >in @ 1+ >a
   begin
      @a '"' = if
         0 !t+  a> 1+ >in !
         comp? if t> (vha) ! (lit4) c, , exit then
         tdrop exit
      then @a+ !t+
   again ;

: "  (quote) ; immediate
: ." (quote) comp? if (ztype) c, exit then ztype ; immediate

: bl 32 ; inline
: tab 9 emit ; inline
: cr 13 emit 10 emit ; inline
: space bl emit ; inline
: negate com 1+ ; inline
: abs dup 0 < if negate then ;

: #neg 0 >a dup 0 < if negate a+ then ;
: #c t@ 1- dup t! c! ;
: #n '0' + dup '9' > if 7 + then #c ;
: <# #neg last 32 - >t 0 t@ c! ;
: #. '.' #c ;
: # base @ /mod swap #n ;
: #s begin # -while drop ;
: #> a@ if '-' #c then t> adrop ;

: (.)  ( n-- ) <# #s #> ztype ;
: .  ( n-- ) (.) space ;
: .2 ( n-- ) <# # #s #> ztype space ;
: .3 ( n-- ) <# # # #s #> ztype space ;
: .hex ( n-- ) base @ >t 16 base ! .2 t> base ! ;
: .dec ( n-- ) base @ >t 10 base ! .3 t> base ! ;
: .bin ( n-- ) base @ >t  2 base ! .  t> base ! ;

: execute ( xt-- ) >r ;
: :noname here 1 state ! ;
: [ 0 state ! ; immediate
: ] 1 state ! ;
: cells cell * ; inline
: cell+ cell + ; inline
: 2+ 1+ 1+ ; inline
: 2* dup + ; inline
: 2/ 2 / ; inline
: 2dup over over ; inline
: 2drop drop drop ; inline
: mod /mod drop ; inline
: ?dup -if dup then ;
: ? @ . ;
: nip  swap drop ; inline
: tuck swap over ; inline
: +! ( n a-- ) tuck @ + swap ! ;
: min ( a b--c ) 2dup > if swap then drop ;
: max ( a b--c ) 2dup < if swap then drop ;

: depth (dsp) @ 1- ;
: lpar '(' emit ; inline
: rpar ')' emit ; inline
: .s lpar space depth ?dup if
      for i 1+ cells dstk + @ . next
   then rpar ;

: dict-end dict dict-sz + 1- ;
: de>xt    @ ;
: de>flags cell + c@ ;
: de>len   cell + 1+ c@ ;
: de>name  cell + 2+ ;
: .de-word de>name ztype t@+ 10 mod if0 cr exit then tab ;
: words last >a 1 >t begin
    a@ .de-word a@ de-sz + a!
    a@ dict-end < while lpar t> 1- . ." words)" adrop ;

( memory / strings )
: fill ( b a n-- ) for 2dup c! 1+ next 2drop ;
: cmove ( src dst n-- ) >r >t >a
    r> ?dup if for @a+ !t+ next then
    atdrop ;
: cmove> ( src dst n-- ) >r  r@ + >t  r@ + >a
    r> ?dup if 1+ for @a- !t- next then
    atdrop ;

: s-end  ( str--end )     dup s-len + ; inline
: s-cat  ( dst src--dst ) over s-end swap s-cpy drop ;
: s-catc ( dst ch--dst )  over s-end tuck c! 0 swap 1+ c! ;
: s-catn ( dst num--dst ) <# #s #> over s-end swap s-cpy drop ;
: p ( --a ) vhere 100 + ;

( screen )
: csi       ( -- )    27 emit '[' emit ;
: ->cr      ( c r-- ) csi (.) ';' emit (.) 'H' emit ;
: ->rc      ( r c-- ) swap ->cr ;
: cls       ( -- )    csi ." 2J" 1 dup ->cr ;
: clr-eol   ( -- )    csi ." 0K" ;
: cur-on    ( -- )    csi ." ?25h" ;
: cur-off   ( -- )    csi ." ?25l" ;
: cur-block ( -- )    csi ." 2 q" ;
: cur-bar   ( -- )    csi ." 5 q" ;

: color   ( bg fg-- ) csi (.) ';' emit (.) 'm' emit ;
: fg      ( fg-- )    40 swap color ;
: white   0 fg ;      : red    31 fg ;
: green  32 fg ;      : yellow 33 fg ;
: blue   34 fg ;      : purple 35 fg ;
: cyan   36 fg ;      : grey   37 fg ;

( blocks )
: disk-sz 1000000 ;
: block-sz 2000 ; inline
disk-sz block-sz / 1- const max-block
vars vars-sz + disk-sz - const disk
: ->block   ( n--a )  block-sz * disk + ;

cell var blk
: rows 25 ; inline
: cols 80 ; inline

( a simple block editor )
block-sz var ed-block
: block->ed ( blk-- ) blk @ ->block ed-block block-sz cmove ;
: ed->block ( blk-- ) ed-block blk @ ->block block-sz cmove ;
cell var (r)  : row! (r) ! ;  : row@ (r) @ ;
cell var (c)  : col! (c) ! ;  : col@ (c) @ ;
: norm-row ( -- ) row@ 0 max rows 1- min row! ;
: norm-col ( -- ) col@ 0 max cols 1- min col! ;
: mv ( r c-- )  (c) +! (r) +! norm-row norm-col ;
: rc->pos ( --pos ) row@ cols * col@ + ed-block + ;
1 var (mode)             : mode@   (mode)  c@ ;
1 var (show)             : show?   (show)  c@ ;
1 var (dirty)            : dirty?  (dirty) c@ ;
: mode! (mode) c! ;      : clean 0 (dirty) c! ;
: show!  1 (show)  c! ;  : shown 0 (show)  c! ;
: dirty! 1 (dirty) c! show! ;
: norm-mode  0 mode! ;
: repl-mode  1 mode! ;
: quit?  mode@ 99 = ;
: .b1  green cols 2+ for '-' emit next white cr ;
: .b2  green '|' emit white ;
: .edch ( a-- ) c@ 32 max emit ;
: .scr 1 dup ->rc .b1 ed-block >a rows for 
      .b2  cols for a@+ .edch next  .b2 cr
   next .b1 adrop ;
: ->cur  col@ 2+ row@ 2+ ->cr ;
: ->foot 1 rows 3 + ->cr ;
: ->cmd ->foot cr ;
: .foot ->foot ." Block #" blk @ . lpar row@ (.) ',' emit col@ (.) rpar ;
: printable? ( c--f ) dup >a 31 >  a> 127 < and ;
: replace-char ( -- ) a@ printable? if a@ rc->pos c! 0 1 mv dirty! then ;
: show show? if cur-off .scr cur-on shown then .foot ->cur ;
: ed-process-key ( -- )
   a@ 'h' = if  0 -1 mv exit then
   a@ 'j' = if  1  0 mv exit then
   a@ 'k' = if -1  0 mv exit then
   a@ 'l' = if  0  1 mv exit then
   a@ 13  = if 1 -99 mv exit then
   a@  3  = if 99 mode! exit then
   replace-char ;
: ed-loop begin show key >a ed-process-key adrop quit? until ;
: ed-init block->ed 0 mode! show! 0 dup row! col! cls ;
: ed  ed-init ed-loop ed->block ->cmd ;
: edit  blk ! ed ;

: reboot
   -vha- (vha) !  -la- (la) !  -ha- (ha) !
   " boot.c5" " rb" fopen ?dup if >a
      vars 10000 + >t 
      0 t@ 99999 fill 
      t@ 99999 a@ fread drop a> fclose
      t> >in !
   then ;

( temp words )
: .ver  green ." c5 v" version <# # # #. # # #. #s #> ztype white cr ;
.ver ." hello"

( temp for testing )

: dump    ( f t-- ) >t >a begin @a+ .    a@ t@ > until atdrop ;
: hexdump ( f t-- ) >t >a begin @a+ .hex a@ t@ > until atdrop ;

: mil 1000 dup * * ;
: elapsed timer swap - . ." usec" ;
: bm timer swap for next elapsed ;
: lg " lazygit" system ;
: ls " ls -l" system ;
: pwd " pwd" system ;
